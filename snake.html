<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>贪吃蛇游戏</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #333 0, #000 60%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
    }
    .container {
      background: rgba(20, 20, 20, 0.95);
      padding: 20px 24px 18px;
      border-radius: 16px;
      box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.75),
        0 0 0 1px rgba(255, 255, 255, 0.04);
    }
    .header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: 12px;
    }
    .title {
      font-size: 20px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #fefefe;
    }
    .subtitle {
      font-size: 12px;
      opacity: 0.7;
    }
    .scoreboard {
      display: flex;
      gap: 12px;
      font-size: 13px;
      margin-bottom: 8px;
    }
    .scoreboard span {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    .score-label {
      opacity: 0.7;
      margin-right: 4px;
    }

    canvas {
      display: block;
      background: #111;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .hint {
      margin-top: 8px;
      font-size: 12px;
      opacity: 0.6;
      display: flex;
      justify-content: space-between;
      gap: 12px;
    }

    .badge {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(76, 175, 80, 0.08);
      border: 1px solid rgba(76, 175, 80, 0.4);
      color: #a5d6a7;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div>
        <div class="title">Snake</div>
        <div class="subtitle">经典贪吃蛇 · 方向键控制</div>
      </div>
      <div class="badge">按空格重新开始</div>
    </div>

    <div class="scoreboard">
      <span><span class="score-label">分数</span><span id="score">0</span></span>
      <span><span class="score-label">最高分</span><span id="highScore">0</span></span>
      <span><span class="score-label">速度</span><span id="speed">中等</span></span>
    </div>

    <canvas id="game" width="400" height="400"></canvas>

    <div class="hint">
      <span>↑ ↓ ← → 控制方向</span>
      <span>吃到食物加分，碰到墙或自己会失败</span>
    </div>
  </div>

  <script>
    // 基础设置
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const tileCount = 20;          // 格子数量（20x20）
    const tileSize = canvas.width / tileCount; // 每个格子的大小

    let snake = [];
    let direction = { x: 1, y: 0 };   // 初始向右
    let food = { x: 10, y: 10 };
    let score = 0;
    let highScore = Number(localStorage.getItem("snake_high_score") || 0);
    let gameOver = false;
    let gameLoopId = null;

    const scoreEl = document.getElementById("score");
    const highScoreEl = document.getElementById("highScore");
    const speedEl = document.getElementById("speed");

    // 难度影响速度：简单/中等/困难
    const speedLevels = {
      easy: 180,
      medium: 120,
      hard: 80,
    };
    let currentSpeed = "medium";

    highScoreEl.textContent = highScore;

    function resetGame() {
      snake = [
        { x: 8, y: 10 },
        { x: 7, y: 10 },
        { x: 6, y: 10 },
      ];
      direction = { x: 1, y: 0 };
      score = 0;
      gameOver = false;
      scoreEl.textContent = "0";
      spawnFood();
      speedEl.textContent =
        currentSpeed === "easy" ? "简单" :
        currentSpeed === "hard" ? "困难" : "中等";

      if (gameLoopId) {
        clearInterval(gameLoopId);
      }
      gameLoopId = setInterval(gameLoop, speedLevels[currentSpeed]);
    }

    function spawnFood() {
      let newFood;
      while (true) {
        newFood = {
          x: Math.floor(Math.random() * tileCount),
          y: Math.floor(Math.random() * tileCount),
        };
        const onSnake = snake.some(seg => seg.x === newFood.x && seg.y === newFood.y);
        if (!onSnake) break;
      }
      food = newFood;
    }

    function gameLoop() {
      if (gameOver) return;

      update();
      draw();
    }

    function update() {
      // 新蛇头位置
      const head = {
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y,
      };

      // 碰墙
      if (
        head.x < 0 ||
        head.x >= tileCount ||
        head.y < 0 ||
        head.y >= tileCount
      ) {
        endGame();
        return;
      }

      // 碰自己
      if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
        endGame();
        return;
      }

      // 头插入到数组最前面
      snake.unshift(head);

      // 吃到食物
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        scoreEl.textContent = score;
        if (score > highScore) {
          highScore = score;
          highScoreEl.textContent = highScore;
          localStorage.setItem("snake_high_score", highScore);
        }
        spawnFood();
        maybeIncreaseSpeed();
      } else {
        // 没吃到就移除尾巴
        snake.pop();
      }
    }

    function maybeIncreaseSpeed() {
      // 简单逻辑：分数越高，速度从简单 -> 中等 -> 困难
      if (score >= 80 && currentSpeed !== "hard") {
        currentSpeed = "hard";
        resetInterval();
      } else if (score >= 30 && currentSpeed === "easy") {
        currentSpeed = "medium";
        resetInterval();
      } else if (score >= 40 && currentSpeed === "medium") {
        currentSpeed = "hard";
        resetInterval();
      }
    }

    function resetInterval() {
      speedEl.textContent =
        currentSpeed === "easy" ? "简单" :
        currentSpeed === "hard" ? "困难" : "中等";
      clearInterval(gameLoopId);
      gameLoopId = setInterval(gameLoop, speedLevels[currentSpeed]);
    }

    function drawGrid() {
      ctx.fillStyle = "#101010";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 画棋盘格子
      for (let x = 0; x < tileCount; x++) {
        for (let y = 0; y < tileCount; y++) {
          const isDark = (x + y) % 2 === 0;
          ctx.fillStyle = isDark ? "#151515" : "#111111";
          ctx.fillRect(
            x * tileSize,
            y * tileSize,
            tileSize,
            tileSize
          );
        }
      }
    }

    function drawSnake() {
      for (let i = 0; i < snake.length; i++) {
        const seg = snake[i];
        const isHead = i === 0;
        const gradient = ctx.createRadialGradient(
          seg.x * tileSize + tileSize * 0.3,
          seg.y * tileSize + tileSize * 0.3,
          2,
          seg.x * tileSize + tileSize / 2,
          seg.y * tileSize + tileSize / 2,
          tileSize
        );
        if (isHead) {
          gradient.addColorStop(0, "#e8f5e9");
          gradient.addColorStop(1, "#66bb6a");
        } else {
          gradient.addColorStop(0, "#a5d6a7");
          gradient.addColorStop(1, "#2e7d32");
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(
          seg.x * tileSize + 1,
          seg.y * tileSize + 1,
          tileSize - 2,
          tileSize - 2
        );

        // 蛇头画个简单的“眼睛”
        if (isHead) {
          ctx.fillStyle = "#111";
          const eyeSize = tileSize * 0.12;
          const offsetX = direction.x === 1 ? tileSize * 0.2 :
                          direction.x === -1 ? tileSize * 0.6 : tileSize * 0.25;
          const offsetYtop = direction.y === 1 ? tileSize * 0.2 :
                             direction.y === -1 ? tileSize * 0.6 : tileSize * 0.25;
          const offsetYbottom = offsetYtop + tileSize * 0.3;

          ctx.beginPath();
          ctx.arc(
            seg.x * tileSize + offsetX,
            seg.y * tileSize + offsetYtop,
            eyeSize,
            0,
            Math.PI * 2
          );
          ctx.fill();

          ctx.beginPath();
          ctx.arc(
            seg.x * tileSize + offsetX,
            seg.y * tileSize + offsetYbottom,
            eyeSize,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
      }
    }

    function drawFood() {
      const gradient = ctx.createRadialGradient(
        food.x * tileSize + tileSize * 0.25,
        food.y * tileSize + tileSize * 0.25,
        2,
        food.x * tileSize + tileSize / 2,
        food.y * tileSize + tileSize / 2,
        tileSize
      );
      gradient.addColorStop(0, "#fff3e0");
      gradient.addColorStop(1, "#ff7043");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(
        food.x * tileSize + tileSize / 2,
        food.y * tileSize + tileSize / 2,
        tileSize * 0.35,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // 小高光
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.beginPath();
      ctx.arc(
        food.x * tileSize + tileSize * 0.4,
        food.y * tileSize + tileSize * 0.4,
        tileSize * 0.12,
        0,
        Math.PI * 2
      );
      ctx.fill();
    }

    function drawGameOver() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.65)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#ff5252";
      ctx.font = "bold 32px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI'";
      ctx.textAlign = "center";
      ctx.fillText("游戏结束", canvas.width / 2, canvas.height / 2 - 10);

      ctx.fillStyle = "#f5f5f5";
      ctx.font = "16px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI'";
      ctx.fillText("按空格重新开始", canvas.width / 2, canvas.height / 2 + 22);
    }

    function draw() {
      drawGrid();
      drawSnake();
      drawFood();
      if (gameOver) {
        drawGameOver();
      }
    }

    function endGame() {
      gameOver = true;
      clearInterval(gameLoopId);
      draw();
    }

    // 键盘控制
    window.addEventListener("keydown", e => {
      const key = e.key;
      if (key === "ArrowUp" && direction.y !== 1) {
        direction = { x: 0, y: -1 };
      } else if (key === "ArrowDown" && direction.y !== -1) {
        direction = { x: 0, y: 1 };
      } else if (key === "ArrowLeft" && direction.x !== 1) {
        direction = { x: -1, y: 0 };
      } else if (key === "ArrowRight" && direction.x !== -1) {
        direction = { x: 1, y: 0 };
      } else if (key === " " || key === "Spacebar") {
        // 空格重开
        if (gameOver) {
          resetGame();
        }
      }
    });

    // 初始化
    resetGame();
    draw();
  </script>
</body>
</html>